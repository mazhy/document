# 正则表达式
##	通配符
1.	搜索指定目录的txt文件:		find ./-name *.txt

## RegExp对象
+	JavaScript 通过内置对象RegExp 支持正则表达式
+ 	有两种方式实例化RegExp对象
	-	字面量	var reg = /\bis\b/g;
	- 	构造函数	var reg = new RegExp('\\bis\\b', 'g')

## 修饰符
+	g: global 全文搜索, 不添加,搜索到第一个匹配停止
+ 	i:	ignore case 忽略大小写,默认大小写敏感
+  m: multiple lines 多行搜索

## 元字符
+	正则表达式由两种基本字符类型组成
	- 原义文本字符
	- 元字符
+	元字符是在正则表达式中有特殊含义的非字母字符
+	* + ? $ ^ . | \ () {} []

##	字符类
+	一般情况下正则表达式一个字符对应字符串的一个字符
+ 	表达式 ab\t 的含义是

+	我们可以使用元字符[] 来构建一个简单的类
+ 	所谓类是指符合某些特性的对象,一个泛指, 而不是特指某个字符
+  表达式[abc] 把字符a,b,c 归为一类,表达式可以匹配这类的字符

## 字符类取反
+	使用元字符 ^ 创建 反向类/负向类
+ 	反向类的意思是不属于某类的内容
+  表达式[^abc] 标示不是字符 a, b ,c 的内容

## 范围类
+	我们可以使用[a-z] 来连接两个字符标示从a到z 的任意字符
+ 这是个闭区间, 也就是包含a和z本身
+ 在[]组成的类内部是可以连写的[a-zA-Z]

## 预定义类

|	预定义 | 原写法	|	表达意义 |
|:---|:---|:----|
|.	|[^\r\n]	|			除了回车符和换行符之外的所有字符|
|	\d	|[0-9]		|			数字字符|
| \D|	[^0-9]	|				非数字字符|
|\s	|[\t\n\x0B\f\r]|		空白符|
| \S	|[^\t\n\x0B\f\r]	|	非空白符|
| \w	|[a-zA-Z_0-9]	|		单词字符(字母,数字下划线)|
| \W	|[^a-zA-Z_0-9]		|	非单词字符|


## 边界
+	正则表达式还提供了几个常用的边界匹配字符

|	字符 | 含义 |
| :-:	|	:-:|
|^|以xxx开始|
|$|以xxx结束|
|\b|单词边界|
|\B|非单词边界|


## 量词
+	我们希望匹配一个连续出现20次的数字的字符串  \d{20}

| 字符 | 含义 |
| :-: | :-: |
|?| 出现零次或一次,最多出现一次|
|+|出现一次或多次 , 至少出现一次|
|*| 出现零次或多次(任意次)|
|{n}|出现n次|
|{n,m}|出现n-m次|
|{n,}|最少出现n次|

## 贪婪模式
+	尽可能多的匹配
+ 	'12345678'.replace(/\d{3,6}/g, 'X')	//	=>	X78

## 非贪婪模式
+	让正则表达式尽可能少的匹配,也就是说一旦成功匹配不再继续尝试
+ 做法就是在量词后面加上 ? 
+ '12345678'.replace(/\d{3,6}?/g, 'X')	// => XX78

## 分组
+	匹配字符串Byron连续出现3次的场景
+ 	用()可以达到分组的功能,使量词作用域分组(Byron){3}

## 或
+	使用 | 可以达到或的效果

```js
'zhangsanzhangsi'.replace(/zhang(san|si)/g,'X');//XX
```

## 反向引用
```js
'2015-12-24'.replace(/(\d{4})-(\d{2})-(\d{2})/g, '$2/$3/$1')
```

+	以() 分组,按照顺序可以用$n代表第几个分组

## 忽略分组
+	不希望捕获某些分组,只需要在分组内加上 ?: 就可以
+ 	(?:Byron).(ok) // $1 == (ok)

## 前瞻
+	正则表达式是从文本头部向尾部开始解析, 文本尾部方向,成为 "前"
+ 前瞻 就是在正则表达式匹配到规则的时候,向前检查是否符合断言,
+ 后顾/ 后瞻 方向相反
+ js不支持后顾
+ 符合和不符合特定断言称为 肯定/正向 匹配和 否定/负向 匹配

|名称|正则|
|:-:|:-:|
|正向前瞻|exp(?=assert)|
|负向前瞻|exp(?!assert)|

## 对象属性
+	global 是否全文搜索,默认false
+ ignore case 是否大小写敏感,默认false
+ multiline 多行搜索,默认为false
+ lastIndex 是当前表达式匹配内容的最后一个字符的下一个位置
+ source 正则表达式的文本字符串

```js
var reg1 = /\w/gmi
reg1.global		//true
reg1.multiline	//true
reg1.ignoreCase	//true
reg1.source		// \w
```


## test
+	RegExp.prototype.test(str)
+	用于测试字符串参数中是否存在匹配正则表达式模式的字符串
+ 如果存在则返回 true , 否则返回 false
+ reg1.test('a')

## exec
+	使用正则表达式模式对字符串执行搜索,并将更新全局RegExp对象的属性以反映匹配结果
+ 如果没有匹配的文本则返回null, 否则返回一个结果数组
	-	index 声明匹配文本的第一个字符的位置
	- 	input 存放被检索的字符串 string
+	调用非全局的RegExp对象的exec()时,返回数组
+ 第一个元素是与正则表达式相匹配的文本
+ 第二个元素是与RegExpObject 的第一个子表达式相匹配的文本(如果有的话)
+ 第三个元素是与RegExp对象的第二个子表达式相匹配的文本(如果有的话,以此类推)

## String.prototype.match(reg)
+	match()方法将检索字符串, 以找到一个或者多个与regexp匹配的文本
+ regexp 是否具有标志g对结果影响很大

###	非全局调用
+	如果regexp没有标记g,那么match() 方法就只能在字符串中执行一次匹配
+ 如果没有找到任何匹配的文本,将返回null
+ 否则他将是返回一个数组,其中存放了与他找到的匹配文本有关的信息
+ 返回数组的第一个元素存放的是匹配文本,而其他的元素存放的是与正则表达式的子表达式匹配的文本
+ 除了常规的数组元素之外,返回的数据还含有2个对象属性
	-	index 声明匹配文本的其实字符在字符串的位置
	- 	input 声明对stringObject的引用

### 全局调用
+	如果regexp具有标志g则match()方法将执行全局检索,找到字符串中的所有匹配子字符串
	-	如果找到任何匹配的子串,则返回null
	- 如果找到了一个或者多个匹配子串,则返回一个数组
+	数组元素中存放的是字符串中所有的匹配子串,而且也没有index属性或input属性

## 模拟框架替换模板
```js
var str = "my name is ${name}, age is ${age}"
var obj = {
  name: 'zhangsan',
  age : 18
}

var reg = /\${(\w+)}/g

var match = str.match(reg)
var matchObj = {}
match.map(item => {
  matchObj[item] = obj[item.slice(2,item.length - 1)]
})
var resultStr = str
for(let key in matchObj) {
  resultStr = replace(resultStr, key, matchObj[key])
}

function replace (str,key, value) {
  return str.replace(key, value)
}
console.log(resultStr)
```

## 手机号

```js
var reg = /^1[34578]\d{9}/
```

















